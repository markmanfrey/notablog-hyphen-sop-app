import { createAgent } from 'notionapi-agent';

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
function getBlockUri(block) {
    if (typeof block === "string") // Got block id
        return `https://www.notion.so/${block.replace(/-/g, "")}`;
    else
        return `https://www.notion.so/${block.id.replace(/-/g, "")}`;
}
function getBlockColor(node) {
    if (node.type === "alias")
        return undefined;
    return node.format ? node.format.block_color : undefined;
}
/**
 * Get emoji character or public accessible URL of the icon of a block
 * @param node - A Notion block
 */
function getBlockIcon(node) {
    if (node.type === "alias")
        return undefined;
    if (node.format && node.format.page_icon) {
        return convertImageUrl(node.id, node.format.page_icon);
    }
    else {
        return undefined;
    }
}
/**
 * Get a link that starts with # if the input URL links to an element
 * in the same page.
 */
function getHashLink(str) {
    const re = /https:\/\/www.notion.so\/.+#([\da-f]+)/;
    const found = str.match(re);
    if (found != null && found[1] != null) {
        return "#" + getBlockUri(found[1]);
    }
    else {
        return str;
    }
}
/**
 * Convert an image source string to a public accessible URL.
 * @param url - Image URL
 * @param width - Image width
 */
function convertImageUrl(blockId, url, width) {
    const isSigned = isNotionSecureUrl(url);
    const baseUrl = (function () {
        if (isSigned) {
            const cleanUrl = url.split("?")[0].replace("s3.us-west", "s3-us-west");
            return `https://www.notion.so/signed/${encodeURIComponent(cleanUrl)}`;
        }
        else if (isNotionRelativePath(url)) {
            return `https://www.notion.so${url}`;
        }
        else {
            return url;
        }
    })();
    const queryParams = [];
    if (width) {
        queryParams.push(`width=${width}`);
    }
    if (isSigned) {
        queryParams.push(`table=block&id=${blockId}`);
    }
    if (queryParams.length) {
        return `${baseUrl}?${queryParams.join("&")}`;
    }
    else {
        return baseUrl;
    }
}
/**
 * Convert a file source string to a public accessible URL.
 * @param url - Image URL
 */
function convertFileUrl(blockId, url) {
    return (function () {
        if (isNotionSecureUrl(url)) {
            const cleanUrl = url.split("?")[0].replace("s3.us-west", "s3-us-west");
            return `https://www.notion.so/signed/${encodeURIComponent(cleanUrl)}?table=block&id=${blockId}`;
        }
        else {
            return url;
        }
    })();
}
/**
 * Whether an URL is a NotionRelativePath.
 *
 * @see https://notionapi.netlify.com/globals.html#notionrelativepath
 *
 * @param url
 */
function isNotionRelativePath(url) {
    const regex = /^\/images?\//;
    return regex.test(url);
}
/**
 * Whether an URL is a NotionSecureUrl.
 *
 * @see https://notionapi.netlify.com/globals.html#notionsecureurl
 *
 * @param url
 */
function isNotionSecureUrl(url) {
    const regex = /^https:\/\/s3.+\.amazonaws\.com\/secure.notion-static.com\//;
    return regex.test(url);
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformAudio(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "audio",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        source: node.properties
            ? node.properties.source
                ? node.properties.source[0][0] : "#"
            : "#"
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformBookmark(node) {
    const props = node.properties;
    return {
        children: [],
        uri: getBlockUri(node),
        type: "bookmark",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        link: props
            ? props.link
                ? props.link[0][0] : "#"
            : "#",
        title: props
            ? props.title
                ? props.title[0][0] : undefined
            : undefined,
        description: props
            ? props.description
                ? props.description[0][0] : undefined
            : undefined,
        icon: node.format ? node.format.bookmark_icon : undefined,
        cover: node.format ? node.format.bookmark_cover : undefined,
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformBreadcrumb(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "breadcrumb",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformTitle(node, // for context info
semanticStrings) {
    if (!semanticStrings)
        return [];
    const newSemanticStrings = [];
    for (let j = 0; j < semanticStrings.length; j++) {
        const ss = semanticStrings[j];
        const text = ss[0];
        const formattings = ss[1];
        if (formattings) {
            const newFormattings = [];
            for (let i = 0; i < formattings.length; i++) {
                const formatting = formattings[i];
                const formattingId = formatting[0];
                const formattingOpt = formatting[1];
                switch (formattingId) {
                    case "a":
                        /**
                         * File & Media columns in Database blocks are stored as links,
                         * so we need to pass the link through convertFileUrl().
                         */
                        newFormattings.push(["a",
                            getHashLink(convertFileUrl(node.id, formattingOpt))]);
                        break;
                    case "u": {
                        const notionUser = await getNotionUser(formattingOpt);
                        newFormattings.push(["u", notionUser]);
                        break;
                    }
                    case "p":
                        newFormattings.push(["p", await getResource(formattingOpt)]);
                        break;
                    default:
                        newFormattings.push([formattingId, formattingOpt]);
                }
            }
            newSemanticStrings.push([text, newFormattings]);
        }
        else {
            newSemanticStrings.push([text]);
        }
    }
    return newSemanticStrings;
}
async function getNotionUser(id) {
    try {
        const notion = createAgent();
        const resp = await notion.getRecordValues({
            requests: [{ table: "notion_user", id }]
        });
        if (resp.results[0].role === "none") {
            return {
                name: "Unknown Notion User"
            };
        }
        else {
            const user = resp.results[0].value;
            return {
                name: user.given_name + " " + user.family_name,
                contacts: [
                    {
                        namespace: "notion.so",
                        identifier: id
                    }, {
                        namespace: "email",
                        identifier: user.email
                    }
                ]
            };
        }
    }
    catch (error) {
        return {
            name: "Unknown Notion User"
        };
    }
}
async function getResource(id) {
    try {
        const notion = createAgent();
        const resp = await notion.getRecordValues({
            requests: [{ table: "block", id }]
        });
        if (resp.results[0].role === "none") {
            return {
                title: [["Unknown Page"]],
                uri: ""
            };
        }
        else {
            const page = resp.results[0].value;
            return {
                title: await transformTitle(page, (page.properties || {}).title),
                uri: getBlockUri(page)
            };
        }
    }
    catch (error) {
        return {
            title: [["Unknown Page"]],
            uri: ""
        };
    }
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformBulletedList(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "bulleted_list",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ? await transformTitle(node, node.properties.title) || [] : []
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformCallout(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "callout",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        icon: getBlockIcon(node),
        title: node.properties ? await transformTitle(node, node.properties.title) || [] : []
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformCode(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "code",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ? await transformTitle(node, node.properties.title) || [] : [],
        language: node.properties
            ? node.properties.language
                ? node.properties.language[0][0] : undefined
            : undefined,
        wrap: (typeof node.format !== "undefined"
            && typeof node.format.code_wrap !== "undefined")
            ? node.format.code_wrap : false
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformPage(node) {
    const format = node.format || {};
    const newProperties = {};
    if (node.properties) {
        const keys = Object.keys(node.properties);
        for (let i = 0; i < keys.length; i++) {
            newProperties[keys[i]] = await transformTitle(node, node.properties[keys[i]]);
        }
    }
    return {
        children: [],
        uri: getBlockUri(node),
        type: "page",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: newProperties.title ? newProperties.title : [],
        icon: getBlockIcon(node),
        cover: format.page_cover
            ? convertImageUrl(node.id, format.page_cover) : undefined,
        fullWidth: typeof format.page_full_width !== "undefined"
            ? format.page_full_width : false,
        coverPosition: format.page_cover_position || 1,
        properties: newProperties
    };
}
async function transformPageOrAlias(node, apiAgent, parent) {
    if (node.type === "page")
        return transformPage(node);
    else {
        const resp = await apiAgent.getRecordValues({
            requests: [{ id: node.format.alias_pointer.id, table: "block" }]
        });
        const page = resp.results[0].value;
        /**
         * HACK: Dereference the alias to the linked page.
         */
        if (parent && parent.content) {
            parent.content = parent.content.map(blockId => blockId === node.id ? page.id : blockId);
        }
        return transformPage(page);
    }
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformCollection(node, apiAgent) {
    const blockId = node.id;
    const viewIds = node.view_ids;
    const collectionId = node.collection_id;
    if (!viewIds) {
        throw new Error(`Collection block ${blockId} has no view.`);
    }
    if (!collectionId) {
        throw new Error(`Collection block ${blockId} has no collection id`);
    }
    /** First, query the collection. */
    const pagesReducerName = "pages";
    const queryResult = await apiAgent.queryCollection({
        collection: {
            id: collectionId
        },
        collectionView: {
            id: viewIds[0]
        },
        loader: {
            type: "reducer",
            reducers: {
                [pagesReducerName]: {
                    type: "results",
                    limit: 1000000,
                    loadContentCover: false
                }
            },
            searchQuery: "",
            userTimeZone: "Asia/Taipei"
        }
    });
    /** Must be the first of the collection recordMap. */
    const collection = Object.values(queryResult.recordMap.collection)[0].value;
    if (!collection) {
        throw new Error(`Fail to get collection ${collectionId}, role is none`);
    }
    /** Get collection views and collection items. */
    const viewsPromise = getCollectionViews(viewIds, apiAgent);
    const pagesPromise = getPageBlocks(queryResult.result
        .reducerResults[pagesReducerName]
        .blockIds, apiAgent);
    const [views, pages] = await Promise.all([viewsPromise, pagesPromise]);
    if (node.type === "collection_view") {
        return {
            children: await Promise.all(pages.map(page => transformPageOrAlias(page, apiAgent))),
            uri: getBlockUri(node),
            type: "collection_inline",
            color: getBlockColor(node),
            createdTime: node.created_time,
            lastEditedTime: node.last_edited_time,
            name: collection.name || [["Untitled"]],
            collectionId,
            defaultViewId: viewIds[0],
            views,
            schema: collection.schema
        };
    }
    else {
        return {
            children: await Promise.all(pages.map(page => transformPageOrAlias(page, apiAgent))),
            uri: getBlockUri(node),
            type: "collection_page",
            color: getBlockColor(node),
            createdTime: node.created_time,
            lastEditedTime: node.last_edited_time,
            name: collection.name || [["Untitled"]],
            collectionId,
            defaultViewId: viewIds[0],
            views,
            schema: collection.schema,
            /**
             * Nasty! For collections, we should use
             * "table=collection&id=<collection_id>",
             * regular convertImageUrl() doesn't work.
             */
            // This is a HACK!!!
            icon: collection.icon
                ? convertImageUrl(collectionId, collection.icon).replace("block", "collection")
                : undefined,
            cover: collection.cover
                ? convertImageUrl(collectionId, collection.cover).replace("block", "collection")
                : undefined,
            description: await transformTitle(node, collection.description),
            coverPosition: collection.format
                ? collection.format.collection_cover_position || 1 : 1
        };
    }
}
/**
 * Get collection views.
 */
async function getCollectionViews(viewIds, apiAgent) {
    const { results } = await apiAgent.getRecordValues({
        requests: viewIds.map((id) => {
            return { id, table: "collection_view" };
        })
    });
    return results.reduce((collectionViews, record) => {
        if (record.role !== "none")
            collectionViews.push(record.value);
        return collectionViews;
    }, []);
}
/**
 * Get page blocks.
 */
async function getPageBlocks(blockIds, apiAgent) {
    const { results } = await apiAgent.getRecordValues({
        requests: blockIds.map((id) => {
            return { id, table: "block" };
        })
    });
    return results.reduce((pageBlocks, record) => {
        if (record.role !== "none")
            pageBlocks.push(record.value);
        return pageBlocks;
    }, []);
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformColumn(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "column",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        ratio: node.format
            ? node.format.column_ratio || 1 : 1
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformColumnList(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "column_list",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformDivider(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "divider",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformEquation(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "equation",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        latex: node.properties
            ? node.properties.title
                ? node.properties.title[0][0] : ""
            : ""
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformFile(node) {
    const props = node.properties;
    return {
        children: [],
        uri: getBlockUri(node),
        type: "file",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        fileId: node.file_ids ? node.file_ids[0] : undefined,
        title: props ? props.title[0][0] : "Unnamed",
        size: props
            ? props.size
                ? props.size[0][0] : undefined
            : undefined,
        source: (function () {
            const src = (props || {}).source;
            if (!src)
                return "";
            else
                return convertFileUrl(node.id, src[0][0]);
        })()
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformHeading(node) {
    let depth;
    switch (node.type) {
        case "header":
            depth = 1;
            break;
        case "sub_header":
            depth = 2;
            break;
        default:
            depth = 3;
    }
    return {
        children: [],
        uri: getBlockUri(node),
        type: "heading",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ? await transformTitle(node, node.properties.title) || [] : [],
        depth
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformNumberedList(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "numbered_list",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ?
            await transformTitle(node, node.properties.title) || [] : []
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformQuote(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "quote",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ?
            await transformTitle(node, node.properties.title) || [] : []
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformTableOfContent(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "table_of_contents",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformText(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "text",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ?
            await transformTitle(node, node.properties.title) || [] : [],
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformToDo(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "to_do",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ?
            await transformTitle(node, node.properties.title) || [] : [],
        checked: node.properties
            ? node.properties.checked
                ? node.properties.checked[0][0] === "Yes" : false
            : false
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformToggle(node) {
    return {
        children: [],
        uri: getBlockUri(node),
        type: "toggle",
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        title: node.properties ?
            await transformTitle(node, node.properties.title) || [] : []
    };
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
function isDirectVideo(url) {
    if (url)
        return /\.mp4|\.ogg|\.webm/.test(url);
    else
        return false;
}
async function transformVisual(node) {
    const format = node.format || {};
    return {
        children: [],
        uri: getBlockUri(node),
        type: (function () {
            if (node.type === "image")
                return "image";
            else if (node.type === "video" && node.format
                && isDirectVideo(node.format.display_source))
                return "video";
            else if (node.type === "pdf")
                return "pdf";
            else
                return "embed";
        })(),
        color: getBlockColor(node),
        createdTime: node.created_time,
        lastEditedTime: node.last_edited_time,
        source: (function () {
            if (node.type === "image")
                return convertImageUrl(node.id, format.display_source || "#", format.block_width);
            else
                return convertFileUrl(node.id, format.display_source
                    || (((node.properties || {}).source || {})[0] || [])[0]
                    || "#");
        })(),
        caption: await getCaption(node),
        width: format.block_width || -1,
        height: format.block_height || -1,
        fullWidth: typeof format.block_full_width !== "undefined"
            ? format.block_full_width : false,
        pageWidth: typeof format.block_page_width !== "undefined"
            ? format.block_page_width : true,
        aspectRatio: format.block_aspect_ratio || -1,
        preserveScale: typeof format.block_preserve_scale !== "undefined"
            ? format.block_preserve_scale : true
    };
}
async function getCaption(node) {
    if (node.type === "image" || node.type === "video"
        || node.type === "embed")
        return node.properties ?
            await transformTitle(node, node.properties.caption) : undefined;
    else
        return undefined;
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function transformBlock(
/** The block to be transformed. */
node, 
/**
 * Some transformers need to make requests to Notion API for more
 * information.
 */
apiAgent, 
/**
 * Some transformers need to modify the parent block.
 * e.g. when dereferencing a pointer to the actual content.
 */
parent) {
    let nastNode;
    switch (node.type) {
        case "breadcrumb": {
            nastNode = transformBreadcrumb(node);
            break;
        }
        case "alias":
        case "page": {
            nastNode = transformPageOrAlias(node, apiAgent, parent);
            break;
        }
        case "collection_view": {
            nastNode = transformCollection(node, apiAgent);
            break;
        }
        case "collection_view_page": {
            nastNode = transformCollection(node, apiAgent);
            break;
        }
        case "file": {
            nastNode = transformFile(node);
            break;
        }
        case "text": {
            nastNode = transformText(node);
            break;
        }
        case "to_do": {
            nastNode = transformToDo(node);
            break;
        }
        case "header": {
            nastNode = transformHeading(node);
            break;
        }
        case "sub_header": {
            nastNode = transformHeading(node);
            break;
        }
        case "sub_sub_header": {
            nastNode = transformHeading(node);
            break;
        }
        case "bulleted_list": {
            nastNode = transformBulletedList(node);
            break;
        }
        case "numbered_list": {
            nastNode = transformNumberedList(node);
            break;
        }
        case "toggle": {
            nastNode = transformToggle(node);
            break;
        }
        case "quote": {
            nastNode = transformQuote(node);
            break;
        }
        case "divider": {
            nastNode = transformDivider(node);
            break;
        }
        case "callout": {
            nastNode = transformCallout(node);
            break;
        }
        case "codepen": {
            nastNode = transformVisual(node);
            break;
        }
        case "embed": {
            nastNode = transformVisual(node);
            break;
        }
        case "invision": {
            nastNode = transformVisual(node);
            break;
        }
        case "pdf": {
            nastNode = transformVisual(node);
            break;
        }
        case "image": {
            nastNode = transformVisual(node);
            break;
        }
        case "video": {
            nastNode = transformVisual(node);
            break;
        }
        case "audio": {
            nastNode = transformAudio(node);
            break;
        }
        case "bookmark": {
            nastNode = transformBookmark(node);
            break;
        }
        case "code": {
            nastNode = transformCode(node);
            break;
        }
        case "equation": {
            nastNode = transformEquation(node);
            break;
        }
        case "column_list": {
            nastNode = transformColumnList(node);
            break;
        }
        case "column": {
            nastNode = transformColumn(node);
            break;
        }
        case "table_of_contents": {
            nastNode = transformTableOfContent(node);
            break;
        }
        default: {
            nastNode = new Promise((resolve) => {
                resolve({
                    children: [],
                    uri: getBlockUri(node),
                    type: node.type,
                    createdTime: node.created_time,
                    lastEditedTime: node.last_edited_time
                });
            });
            console.log(`Unsupported block type: ${node.type}`);
        }
    }
    return nastNode;
}

/**
 * Copyright (c) 2019-present Wen-Zhi Wang <zxcvb22217@gmail.com>
 * All rights reserved.
 *
 * Use of this source code is governed by a MIT license that can be found
 * in the LICENSE file.
 */
async function getOnePageAsTree(pageId, apiAgent) {
    const allBlocks = await getAllBlocksInOnePage(pageId, apiAgent);
    return makeBlockArrayIntoTree(allBlocks, apiAgent);
}
async function getAllBlocksInOnePage(pageId, apiAgent) {
    /**
     * getChildrenBlocks() does not download children of a page,
     * so we should get the page first.
     */
    const request = generateGRVPayload([pageId], "block");
    const response = await apiAgent.getRecordValues(request);
    const record = response.results[0];
    if (record.role === "none") {
        throw new Error(`Fail to get page ${pageId}, role is "none"`);
    }
    const pageBlock = record.value;
    const childrenIdsOfPageBlock = pageBlock.content;
    let allRecords = [pageBlock];
    if (childrenIdsOfPageBlock) {
        /* Get all records in a flat array. */
        const children = await getChildrenBlocks(childrenIdsOfPageBlock, apiAgent);
        allRecords = allRecords.concat(children);
    }
    return allRecords;
}
/**
 * Generate request payload for getRecordValues API.
 * @param ids - Notion record ID array.
 * @param table - The table to query.
 * @returns The payload.
 */
function generateGRVPayload(ids, table) {
    const requests = ids.map((id) => {
        return { id, table };
    });
    return {
        requests
    };
}
/**
 * Recursively get all valid blocks in a page.
 */
async function getChildrenBlocks(blockIds, apiAgent) {
    /** Get children records with getRecordValues */
    const request = generateGRVPayload(blockIds, "block");
    const response = await apiAgent.getRecordValues(request);
    const childrenRecords = response.results;
    const validBlocks = childrenRecords
        .reduce((blocks, record, index) => {
        if (record.role !== "none")
            blocks.push(record.value);
        else
            console.log(`Fail to get block ${request.requests[index].id}, 
role is none`);
        return blocks;
    }, []);
    const validBlocksNonPage = validBlocks
        .filter((block) => {
        return block.type !== "page";
    });
    const childrenToGet = validBlocksNonPage
        .reduce((childrenIds, block) => {
        if (block.content)
            return childrenIds.concat(block.content);
        else
            return childrenIds;
    }, []);
    if (childrenToGet.length > 0) {
        return validBlocks.concat(await getChildrenBlocks(childrenToGet, apiAgent));
    }
    else {
        return validBlocks;
    }
}
/**
 * Convert block array to NAST.
 */
async function makeBlockArrayIntoTree(blocks, apiAgent) {
    /* Transform Notion Block to NAST.Block */
    const nastBlocks = await Promise.all(blocks
        .map((block) => {
        const parent = blocks.find(b => b.id === block.parent_id);
        return transformBlock(block, apiAgent, parent); // block, parent, context {apiAgent}
    }));
    /* A map <block id, reference in nastBlocks> */
    const nastBlockMap = {};
    for (let i = 0; i < nastBlocks.length; ++i) {
        nastBlockMap[nastBlocks[i].uri] = nastBlocks[i];
    }
    /* The tree's root is always the first. */
    const treeRoot = nastBlocks[0];
    /**
     * Wire up each block's children
     * Iterate through blocks and get children IDs from
     * `nonEmptyRecords[i].value.content`, then find each child's reference
     * by ID using `map`.
     */
    for (let i = 0; i < blocks.length; ++i) {
        const childrenIds = blocks[i].content;
        if (!childrenIds)
            continue;
        childrenIds.forEach(id => {
            const childNastBlock = nastBlockMap[getBlockUri(id)];
            if (childNastBlock)
                nastBlocks[i].children.push(childNastBlock);
        });
    }
    return treeRoot;
}

export { getAllBlocksInOnePage, getOnePageAsTree };
