import { createElement, Fragment } from 'react';
import { renderToStaticMarkup } from 'react-dom/server';
import katex from 'katex';
import Prism from 'prismjs';

const COLOR = {
    gray: "gray",
    brown: "brown",
    orange: "orange",
    yellow: "yellow",
    green: "green",
    teal: "teal",
    blue: "blue",
    purple: "purple",
    pink: "pink",
    red: "red",
    grayBg: "gray_background",
    brownBg: "brown_background",
    orangeBg: "orange_background",
    yellowBg: "yellow_background",
    tealBg: "teal_background",
    blueBg: "blue_background",
    purpleBg: "purple_background",
    pinkBg: "pink_background",
    redBg: "red_background"
};
/**
 * Convert a color name in NAST to a color in UI.
 * @param color One of the color names defined in `COLOR`.
 * @returns A class name with a color modifier.
 */
function convertColor(color) {
    const colorPrefix = `Color`;
    const bgPrefix = `Bg`;
    switch (color) {
        case COLOR.gray:
            return colorPrefix + "Gray";
        case COLOR.brown:
            return colorPrefix + "Brown";
        case COLOR.orange:
            return colorPrefix + "Orange";
        case COLOR.yellow:
            return colorPrefix + "Yellow";
        case COLOR.green:
        case COLOR.teal:
            return colorPrefix + "Green";
        case COLOR.blue:
            return colorPrefix + "Blue";
        case COLOR.purple:
            return colorPrefix + "Purple";
        case COLOR.pink:
            return colorPrefix + "Pink";
        case COLOR.red:
            return colorPrefix + "Red";
        case COLOR.grayBg:
            return bgPrefix + "Gray";
        case COLOR.brownBg:
            return bgPrefix + "Brown";
        case COLOR.orangeBg:
            return bgPrefix + "Orange";
        case COLOR.yellowBg:
            return bgPrefix + "Yellow";
        case COLOR.tealBg:
            return bgPrefix + "Green";
        case COLOR.blueBg:
            return bgPrefix + "Blue";
        case COLOR.purpleBg:
            return bgPrefix + "Purple";
        case COLOR.pinkBg:
            return bgPrefix + "Pink";
        case COLOR.redBg:
            return bgPrefix + "Red";
        default:
            return colorPrefix + "Default";
    }
}
/**
 * Make a block colorful.
 * @param color One of the color names defined in `COLOR`.
 * @returns A CSS class name string to add to a HTML element.
 */
function colorfulBlock(color) {
    const blockName = "ColorfulBlock";
    return `${blockName} ${blockName}--${convertColor(color)}`;
}
/**
 * Escape special characters in a string.
 *
 * @see https://github.com/facebook/react/blob/1034e26fe5e42ba07492a736da7bdf5bf2108bc6/packages/react-dom/src/server/escapeTextForBrowser.js
 * @see https://github.com/rack/rack/issues/27
 *
 * @param str An unescaped string.
 * @returns An escaped string.
 */
function escapeString(str) {
    if (!str)
        return "";
    let character, escapedString = "";
    for (let i = 0; i < str.length; ++i) {
        character = str.charAt(i);
        switch (character) {
            case "<":
                escapedString += "&lt;";
                break;
            case ">":
                escapedString += "&gt;";
                break;
            case "&":
                escapedString += "&amp;";
                break;
            case "'":
                escapedString += "&#x27;";
                break;
            case "\"":
                escapedString += "&quot;";
                break;
            // case "/":
            //   escapedString += "&#x2F;"
            //   break
            // case "\"":
            //   escapedString += "&quot;"
            //   break
            default:
                escapedString += character;
        }
    }
    return escapedString;
}
function prettyTime(jsHour, jsMinute) {
    const ampm = jsHour >= 12 ? "PM" : "AM";
    const hour = (jsHour % 12) ? (jsHour % 12) : 12;
    return `${hour}:${jsMinute.toString().padStart(2, "0")} ${ampm}`;
}
function prettyDate(timestamp) {
    const d = new Date(timestamp);
    const monthAbbrs = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    ];
    const month = monthAbbrs[d.getMonth()];
    const date = d.getDate();
    const year = d.getFullYear();
    const hour = d.getHours();
    const minute = d.getMinutes();
    return `${month} ${date}, ${year} ${prettyTime(hour, minute)}`;
}

/**
 * Using import/from cause an TS error, so fallback to const/require
 */
const loadLanguages = require("prismjs/components/index");
/**
 * The following has wrong data and is for temporary use.
 */
const languages = {
    "html": "HTML",
    "xml": "XML",
    "svg": "SVG",
    "mathml": "MathML",
    "css": "CSS",
    "clike": "C",
    "javascript": "JavaScript",
    "abap": "ABAP",
    "abnf": "Augmented Backus–Naur form",
    "apacheconf": "Apache Configuration",
    "apl": "APL",
    "arff": "ARFF",
    "asciidoc": "AsciiDoc",
    "adoc": "AsciiDoc",
    "asm6502": "6502 Assembly",
    "aspnet": "ASP.NET (C#)",
    "autohotkey": "AutoHotkey",
    "autoit": "AutoIt",
    "shell": "Bash",
    "basic": "BASIC",
    "bnf": "Backus–Naur form",
    "rbnf": "Routing Backus–Naur form",
    "csharp": "C#",
    "cs": "C#",
    "dotnet": "C#",
    "cpp": "C++",
    "cil": "CIL",
    "coffee": "CoffeeScript",
    "cmake": "CMake",
    "csp": "Content-Security-Policy",
    "css-extras": "CSS Extras",
    "django": "Django/Jinja2",
    "jinja2": "Django/Jinja2",
    "dns-zone-file": "DNS zone file",
    "dns-zone": "DNS zone file",
    "dockerfile": "Docker",
    "ebnf": "Extended Backus–Naur form",
    "ejs": "EJS",
    "erb": "ERB",
    "fsharp": "F#",
    "gcode": "G-code",
    "gedcom": "GEDCOM",
    "glsl": "GLSL",
    "gml": "GameMaker Language",
    "gamemakerlanguage": "GameMaker Language",
    "graphql": "GraphQL",
    "hs": "Haskell",
    "hcl": "HCL",
    "http": "HTTP",
    "hpkp": "HTTP Public-Key-Pins",
    "hsts": "HTTP Strict-Transport-Security",
    "ichigojam": "IchigoJam",
    "inform7": "Inform 7",
    "javadoc": "JavaDoc",
    "javadoclike": "JavaDoc-like",
    "javastacktrace": "Java stack trace",
    "jq": "JQ",
    "jsdoc": "JSDoc",
    "js-extras": "JS Extras",
    "json": "JSON",
    "jsonp": "JSONP",
    "json5": "JSON5",
    "latex": "LaTeX",
    "tex": "TeX",
    "context": "ConTeXt",
    "lilypond": "LilyPond",
    "ly": "LilyPond",
    "emacs": "Lisp",
    "elisp": "Lisp",
    "emacs-lisp": "Lisp",
    "lolcode": "LOLCODE",
    "md": "Markdown",
    "markup-templating": "Markup templating",
    "matlab": "MATLAB",
    "mel": "MEL",
    "n1ql": "N1QL",
    "n4js": "N4JS",
    "n4jsd": "N4JS",
    "nand2tetris-hdl": "Nand To Tetris HDL",
    "nasm": "NASM",
    "nginx": "nginx",
    "nsis": "NSIS",
    "objectivec": "Objective-C",
    "ocaml": "OCaml",
    "opencl": "OpenCL",
    "parigp": "PARI/GP",
    "objectpascal": "Object Pascal",
    "pcaxis": "PC-Axis",
    "px": "PC-Axis",
    "php": "PHP",
    "phpdoc": "PHPDoc",
    "php-extras": "PHP Extras",
    "plsql": "PL/SQL",
    "powershell": "PowerShell",
    "properties": ".properties",
    "protobuf": "Protocol Buffers",
    "py": "Python",
    "q": "Q (kdb+ database)",
    "jsx": "React JSX",
    "tsx": "React TSX",
    "renpy": "Ren'py",
    "rest": "reST (reStructuredText)",
    "rb": "Ruby",
    "sas": "SAS",
    "sass": "Sass (Sass)",
    "scss": "Sass (Scss)",
    "shell-session": "Shell session",
    "soy": "Soy (Closure Template)",
    "splunk-spl": "Splunk SPL",
    "sql": "SQL",
    "tap": "TAP",
    "toml": "TOML",
    "tt2": "Template Toolkit 2",
    "ts": "TypeScript",
    "t4-cs": "T4 Text Templates (C#)",
    "t4": "T4 Text Templates (C#)",
    "t4-vb": "T4 Text Templates (VB)",
    "t4-templating": "T4 templating",
    "vbnet": "VB.Net",
    "vhdl": "VHDL",
    "vim": "vim",
    "visual-basic": "Visual Basic",
    "vb": "Visual Basic",
    "wasm": "WebAssembly",
    "wiki": "Wiki markup",
    "xeoracube": "XeoraCube",
    "xojo": "Xojo (REALbasic)",
    "xquery": "XQuery",
    "yaml": "YAML",
    "yml": "YAML"
};
/**
 * TODO: Complete the following map. The key is the string used in Notion,
 * and the value is the one used in prismjs.
 *
 * TODO: We should not handle Notion-specific stuffs here, instead, map
 * these strings to prismjs compatible ones in nast-util-from-notionapi.
 *
 * To extract Notion-specific language strings, get a code block,
 * use devtool to copy the html of language selection popup, then apply
 * this regex on the html string:
 * `<div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">([^<]+)[<]`
 *
 * On regex101, we can export the matched groups as JSON.
 */
const map = {
    "ABAP": "abap",
    "Arduino": "arduino",
    "Bash": "shell",
    "BASIC": "basic",
    "C": "c",
    "Clojure": "clojure",
    "CoffeeScript": "coffeescript",
    "C++": "cpp",
    "C#": "csharp",
    "CSS": "css",
    "Dart": "dart",
    "Diff": "diff",
    "Docker": "docker",
    "Elixir": "elixir",
    "Elm": "elm",
    "Java": "java"
};
Object.entries(languages).forEach(pair => {
    if (!map[pair[1]]) {
        Object.defineProperty(map, pair[1], {
            value: pair[0]
        });
    }
});
function renderCode(str, lang) {
    const codeLang = getLangString(lang);
    if (lang && codeLang) {
        /**
         * Prismjs will do char escape.
         *
         * loadLanguages can not be used with webpack.
         * https://github.com/PrismJS/prism/issues/1477
         */
        loadLanguages([codeLang]);
        return Prism.highlight(str, Prism.languages[codeLang], codeLang);
    }
    else {
        /**
         * If user does not specify language, "lang" is undefined, so we just
         * return the plain text.
         */
        return escapeString(str);
    }
}
function getLangString(str) {
    if (!str)
        return undefined;
    else {
        let lang = map[str];
        if (lang != null)
            return lang;
        else
            return undefined;
    }
}

function SemanticStringArray(props) {
    /**
     * In case TypeScript fails to detect type mismatch, or an unexpected
     * runtime edge case occurred.
     */
    const ssArr = props.semanticStringArray || [];
    return (createElement("span", { className: "SemanticStringArray" }, ssArr.map((ss, i) => createElement(SemanticString, { semanticString: ss, isCode: props.isCode, codeLang: props.codeLang, noInteractive: props.noInteractive, key: i }))));
}
function SemanticString(props) {
    const blockName = "SemanticString";
    const text = props.semanticString[0];
    const formattings = props.semanticString[1] || [];
    let renderedText;
    if (props.isCode) {
        // TODO: Can this be rendered without <span> ?
        renderedText = createElement("span", { dangerouslySetInnerHTML: {
                __html: renderCode(text, props.codeLang)
            } });
    }
    else {
        renderedText = createElement(Fragment, text);
    }
    renderedText = formattings.reduce((rendered, formatting) => {
        const elemName = `${blockName}__Fragment`;
        const formattingId = formatting[0];
        const formattingOpts = formatting[1];
        switch (formattingId) {
            /* Bold */
            case "b":
                return rendered =
                    createElement("strong", { className: `${elemName} ${elemName}--Bold` }, rendered);
            /* Italic */
            case "i":
                return rendered =
                    createElement("em", { className: `${elemName} ${elemName}--Italic` }, rendered);
            /* Strike */
            case "s":
                return rendered =
                    createElement("del", { className: `${elemName} ${elemName}--Strike` }, rendered);
            /* Link */
            case "a": {
                const link = formattingOpts;
                return rendered = props.noInteractive ?
                    rendered :
                    createElement("a", { className: `${elemName} ${elemName}--Link`, href: link }, rendered);
            }
            /* Inline Code */
            case "c":
                return rendered =
                    createElement("code", { className: `${elemName} ${elemName}--Code` }, rendered);
            /* Color or Background Color */
            case "h": {
                const color = convertColor(formattingOpts);
                const hType = color.startsWith("Bg") ? "Bg" : "Color";
                return rendered =
                    createElement("mark", { className: `${elemName} ${elemName}--Highlighted${hType} ${elemName}--${color}` }, rendered);
            }
            /* Comment */
            case "m":
                return rendered =
                    createElement("span", { className: `${elemName} ${elemName}--Commented` }, rendered);
            /** Inline Mention Individual */
            case "u": {
                const individual = formattingOpts;
                return rendered =
                    createElement("span", { className: `${elemName} ${elemName}--Individual` },
                        createElement(InlineMentionIndividual, { data: individual }));
            }
            /** Inline Mention Resource */
            case "p": {
                const resource = formattingOpts;
                return rendered =
                    createElement("span", { className: `${elemName} ${elemName}--Resource` },
                        createElement(InlineMentionResource, { data: resource, noInteractive: props.noInteractive }));
            }
            /** Inline Mention Date */
            case "d": {
                const date = formattingOpts;
                return rendered =
                    createElement("span", { className: `${elemName} ${elemName}--Date` },
                        createElement(InlineMentionDate, { data: date }));
            }
            /** Inline Math */
            case "e": {
                const latex = formattingOpts;
                const katexOpts = {
                    throwOnError: false
                };
                return rendered =
                    createElement("span", { className: `${elemName} ${elemName}--Math`, dangerouslySetInnerHTML: {
                            __html: katex.renderToString(latex, katexOpts)
                        }, "data-latex": latex });
            }
            default:
                console.log(`Unsupported formatting: ${JSON.stringify(formatting)}`);
                return rendered =
                    createElement("span", { className: `${elemName} ${elemName}--Unknown` }, rendered);
        }
    }, renderedText);
    return createElement("span", { className: blockName }, renderedText);
}
function InlineMentionIndividual(props) {
    return (createElement(Fragment, null,
        "@",
        props.data.name));
}
function InlineMentionResource(props) {
    if (props.noInteractive) {
        return (createElement(SemanticStringArray, { semanticStringArray: props.data.title, noInteractive: true }));
    }
    else {
        return (createElement("a", { href: props.data.uri },
            createElement(SemanticStringArray, { semanticStringArray: props.data.title, noInteractive: false })));
    }
}
function InlineMentionDate(props) {
    const startDate = new Date(props.data.start_date);
    const endDate = props.data.end_date ?
        new Date(props.data.end_date) : undefined;
    const dateToString = function (d) {
        return `@${d.getUTCFullYear()}/\
${(d.getUTCMonth() + 1).toString().padStart(2, "0")}/\
${d.getUTCDate().toString().padStart(2, "0")}`;
    };
    return (createElement(Fragment, null, `${dateToString(startDate)}${endDate ?
        ` → ${dateToString(endDate)}` : ""}`));
}

function Audio(props) {
    return (createElement("audio", { id: props.current.uri, className: "Audio", controls: true },
        createElement("source", { src: props.current.source })));
}

function Bookmark(props) {
    const cname = "Bookmark";
    const data = props.current;
    return (createElement("div", { id: data.uri, className: cname },
        createElement("a", { href: data.link },
            data.title ?
                createElement("h5", { className: `${cname}__Title` }, data.title) : "",
            data.description ?
                createElement("p", { className: `${cname}__Desc` }, data.description) : "",
            createElement("p", { className: `${cname}__Link` }, data.link))));
}

function BulletedList(props) {
    return (createElement("li", { key: props.current.uri, id: props.current.uri, className: "BulletedList" },
        createElement(SemanticStringArray, { semanticStringArray: props.current.title }),
        props.children));
}
function BulletedListWrapper(props) {
    return (createElement("ul", { className: "BulletedListWrapper" }, props.children));
}

function Icon(props) {
    const cname = "Icon";
    const isEmoji = !/^http/.test(props.src);
    const defaultSize = "1em";
    const style = {
        width: props.size || defaultSize,
        height: props.size || defaultSize,
    };
    if (isEmoji) {
        return createElement("div", { className: cname }, props.src);
    }
    else {
        return createElement("img", { className: cname, style: style, src: props.src });
    }
}

function Callout(props) {
    const blockName = "Callout";
    const data = props.current;
    return (createElement("div", { id: data.uri, className: `${colorfulBlock(data.color)} ${blockName}` },
        createElement("div", { className: `${blockName}__Icon` }, data.icon ?
            createElement(Icon, { src: data.icon, size: "1.5em" }) : ""),
        createElement("p", { className: `${blockName}__Content` },
            createElement(SemanticStringArray, { semanticStringArray: data.title }),
            props.children)));
}

function Code(props) {
    const className = props.current.wrap ? "Code" : "Code Code--NoWrap";
    return (createElement("pre", { id: props.current.uri, className: className },
        createElement("code", null,
            createElement(SemanticStringArray, { semanticStringArray: props.current.title, isCode: true, codeLang: props.current.language }))));
}

/** A link with an icon. Usually put beside a heading.  */
function Anchor(props) {
    return (createElement("a", { className: "Anchor", href: `#${props.href}` },
        createElement("svg", { width: "16", height: "16", viewBox: "0 0 16 16" },
            createElement("path", { fillRule: "evenodd", d: "M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" }))));
}

function Pill(props) {
    const blockName = "Pill";
    const color = convertColor(props.color);
    return (createElement("span", { className: `${blockName} ${blockName}--${color}` }, props.content));
}

function createAccessor(column, columnId) {
    return function (row) {
        /**
         * A common place to get the column value.
         * However, some types of column values are at other places.
         */
        const data = (row.properties || {})[columnId];
        switch (column.type) {
            case "title":
                return {
                    type: column.type,
                    value: row.title
                };
            case "checkbox":
                return {
                    type: column.type,
                    value: data ? data[0][0] === "Yes" : false
                };
            case "select":
            case "multi_select": {
                const optionNames = data ? data[0][0].split(",") : [];
                return {
                    type: column.type,
                    value: optionNames.map(optionName => {
                        const option = (column.options || [])
                            .find(o => o.value === optionName);
                        if (!option) {
                            console.log(`Select option "${optionName}" is \
not found on property "${columnId}:${column.name}".`);
                            return {
                                color: "default",
                                value: optionName
                            };
                        }
                        else {
                            return {
                                color: option.color,
                                value: option.value
                            };
                        }
                    })
                };
            }
            // TODO: NAST currently do not have the following 2 information.
            case "created_by":
            case "last_edited_by":
                return {
                    type: column.type,
                    value: "Someone"
                };
            case "created_time":
                return {
                    type: column.type,
                    value: row.createdTime
                };
            case "last_edited_time":
                return {
                    type: column.type,
                    value: row.lastEditedTime
                };
            default:
                return {
                    type: column.type,
                    value: (row.properties || {})[columnId]
                };
        }
    };
}
function Collection(props) {
    const viewType = props.view.type;
    switch (viewType) {
        case "table":
            return createElement(Table, { ...props });
        case "gallery":
            return createElement(Gallery, { ...props });
        default:
            console.log(`Collection view type "${viewType}" is unsupported`);
            return createElement(Fragment, null);
    }
}
function CollectionDriver(props) {
    const data = props.current;
    const view = data.views.find(view => view.id === data.defaultViewId);
    const columns = Object.keys(data.schema).map(colId => {
        const col = data.schema[colId];
        return {
            id: colId,
            name: col.name,
            type: col.type,
            options: col.options,
            accessor: createAccessor(col, colId)
        };
    });
    const rows = data.children;
    if (!view) {
        console.log(`Cannot find default view "${data.defaultViewId}" in \
collection "${data.collectionId}"`);
        return createElement(Fragment, null);
    }
    if (data.type === "collection_page") {
        return (createElement("main", { id: data.uri, className: "CollectionPage" },
            createElement(Collection, { view: view, columns: columns, rows: rows })));
    }
    else {
        return (createElement("div", { id: data.uri, className: "CollectionInline" },
            createElement("h3", null,
                createElement(Anchor, { href: data.uri }),
                createElement(SemanticStringArray, { semanticStringArray: data.name })),
            createElement(Collection, { view: view, columns: columns, rows: rows })));
    }
}
function Table(props) {
    const blockName = "Table";
    const viewFormat = props.view.format;
    const columnMap = (function () {
        const map = {};
        props.columns.forEach(col => map[col.id] = col);
        return map;
    })();
    const visibleColumns = (viewFormat.table_properties || [])
        .filter(colViewInfo => colViewInfo.visible)
        /**
         * Some collection views have "ghost" properties that don"t exist
         * in collection schema.
         */
        .filter(colViewInfo => columnMap[colViewInfo.property])
        .map(colViewInfo => {
        const colId = colViewInfo.property;
        return {
            ...columnMap[colId],
            id: colId,
            width: colViewInfo.width
        };
    });
    const tableHeadCells = visibleColumns.map(col => createElement("th", { key: col.id, style: col.width ? { width: `${col.width}px` } : {} }, col.name));
    const tableRows = props.rows
        .filter(row => row.properties)
        .map(row => {
        return (createElement("tr", { key: row.uri }, visibleColumns.map(col => {
            const elemNameBase = `${blockName}__Cell`;
            const data = col.accessor.call(null, row);
            switch (data.type) {
                case "title": {
                    return (createElement("td", { key: col.id, className: `${elemNameBase}Title` },
                        createElement("a", { href: row.uri },
                            createElement(SemanticStringArray, { semanticStringArray: row.title }))));
                }
                case "checkbox": {
                    const elemName = `${elemNameBase}Checkbox`;
                    const checked = data.value;
                    return (createElement("td", { key: col.id, className: `${elemName} ${checked ?
                            `${elemName}--Yes` : `${elemName}--No`}` },
                        createElement("div", { style: checked ? { background: "rgb(46, 170, 220)" } : {} }, checked ?
                            createElement("svg", { viewBox: "0 0 14 14" },
                                createElement("polygon", { points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039" })) :
                            createElement("svg", { viewBox: "0 0 16 16" },
                                createElement("path", { d: "M1.5,1.5 L1.5,14.5 L14.5,14.5 L14.5,1.5 L1.5,1.5 Z M0,0 L16,0 L16,16 L0,16 L0,0 Z" })))));
                }
                case "select":
                case "multi_select": {
                    const options = data.value;
                    return (createElement("td", { key: col.id, className: `${elemNameBase}Select` }, options.map((option, index) => {
                        return (createElement(Pill, { key: index, content: option.value, color: option.color }));
                    })));
                }
                case "created_by":
                case "last_edited_by": {
                    return (createElement("td", { key: col.id, className: `${elemNameBase}CreatedEditedBy` }, data.value));
                }
                case "created_time":
                case "last_edited_time": {
                    return (createElement("td", { key: col.id, className: `${elemNameBase}CreatedEditedTime` }, prettyDate(data.value)));
                }
                default:
                    return (createElement("td", { key: col.id, className: `${elemNameBase}Text` },
                        createElement(SemanticStringArray, { semanticStringArray: data.value })));
            }
        })));
    });
    return (createElement("div", { className: blockName },
        createElement("table", null,
            createElement("thead", null,
                createElement("tr", null, tableHeadCells)),
            createElement("tbody", null, tableRows))));
}
function Gallery(props) {
    const blockName = "Gallery";
    const viewFormat = props.view.format;
    const imageContain = viewFormat.gallery_cover_aspect
        ? viewFormat.gallery_cover_aspect === "contain" : false;
    const columnMap = (function () {
        const map = {};
        props.columns.forEach(col => map[col.id] = col);
        return map;
    })();
    const visibleColumns = (viewFormat.gallery_properties || [])
        .filter(colViewInfo => colViewInfo.visible)
        /**
         * Some collection views have "ghost" properties that don"t exist
         * in collection schema.
         */
        .filter(colViewInfo => columnMap[colViewInfo.property])
        .map(colViewInfo => {
        const colId = colViewInfo.property;
        return {
            ...columnMap[colId],
            id: colId,
        };
    });
    const galleryItems = props.rows.map(row => {
        return (createElement("article", { key: row.uri, id: row.uri, className: `${blockName}__Item` },
            createElement("div", null,
                createElement("div", null,
                    createElement("a", { href: row.uri },
                        createElement("div", { className: `${blockName}__Item__Cover ${imageContain ?
                                `${blockName}__Item__Cover--Contain` : ""}` }, row.cover ? createElement("img", { src: row.cover }) : "")),
                    createElement("div", { className: `${blockName}__Item__Title` },
                        createElement(SemanticStringArray, { semanticStringArray: row.title })),
                    visibleColumns.map(col => {
                        const elemNameBase = `${blockName}__Item__Property ${blockName}__Item__Property`;
                        const data = col.accessor.call(null, row);
                        switch (data.type) {
                            /** "title" is always displayed. */
                            case "select":
                            case "multi_select": {
                                const options = data.value;
                                if (options.length > 0)
                                    return (createElement("div", { key: col.id, className: `${elemNameBase}Select` }, options.map((option, index) => {
                                        return (createElement(Pill, { key: index, content: option.value, color: option.color }));
                                    })));
                            }
                            case "checkbox":
                            case "created_by":
                            case "last_edited_by":
                            case "created_time":
                            case "last_edited_time":
                                return createElement(Fragment, { key: col.id }); // An empty React.Fragment, which renders to nothing.
                            default:
                                if (typeof data.value !== 'undefined')
                                    return (createElement("div", { key: col.id, className: `${elemNameBase}Text` },
                                        createElement(SemanticStringArray, { semanticStringArray: data.value })));
                        }
                    })))));
    });
    return (createElement("div", { className: blockName }, galleryItems));
}

function ColumnList(props) {
    return (createElement("div", { id: props.current.uri, className: "ColumnList" }, props.children));
}
function Column(props) {
    const style = {
        width: `calc((100% - var(--column-spacing) * ${props.listLength - 1}) * ${props.current.ratio})`
    };
    return (createElement("div", { id: props.current.uri, className: "Column", style: style }, props.children));
}

function Divider(props) {
    return (createElement("div", { id: props.current.uri, className: "Divider" }));
}

function Embed(props) {
    const blockName = "Embed";
    const data = props.current;
    const width = data.fullWidth ? "100%" : `${data.width}px`;
    const height = data.height;
    const src = data.source;
    const aspectRatio = data.aspectRatio * 100;
    const iframeSandbox = "allow-scripts allow-popups allow-forms allow-same-origin";
    return (createElement("div", { id: data.uri, className: blockName },
        createElement("div", { className: `${blockName}__Content` },
            createElement("div", { className: `${blockName}__ResponsiveContainer`, style: (data.aspectRatio === -1) ?
                    {
                        width, height
                    } :
                    {
                        width, paddingBottom: `${aspectRatio}%`
                    } },
                createElement("iframe", { src: src, sandbox: iframeSandbox, allowFullScreen: true }))),
        data.caption ?
            createElement("p", { className: `${blockName}__Caption` },
                createElement(SemanticStringArray, { semanticStringArray: data.caption })) : ""));
}

function Equation(props) {
    const katexOpts = {
        throwOnError: false,
        displayMode: true
    };
    const { latex, ...remainingProps } = props;
    return (createElement("p", { ...remainingProps, dangerouslySetInnerHTML: {
            __html: katex.renderToString(latex, katexOpts)
        }, "data-latex": latex }));
}
function EquationDriver(props) {
    const blockName = "Equation";
    const data = props.current;
    return (createElement(Equation, { id: props.current.uri, className: blockName, latex: data.latex }));
}

function File(props) {
    const cname = "File";
    const data = props.current;
    return (createElement("a", { id: data.uri, className: cname, href: data.source },
        createElement("div", null,
            createElement("div", { className: `${cname}__Icon` },
                createElement("svg", { viewBox: "0 0 30 30", style: {
                        width: "1.35em",
                        height: "1.35em",
                        fill: "inherit"
                    } },
                    createElement("g", null,
                        createElement("path", { d: "M22,8v12c0,3.866-3.134,7-7,7s-7-3.134-7-7V8c0-2.762,2.238-5,5-5s5,2.238,5,5v12c0,1.657-1.343,3-3,3s-3-1.343-3-3V8h-2v12c0,2.762,2.238,5,5,5s5-2.238,5-5V8c0-3.866-3.134-7-7-7S6,4.134,6,8v12c0,4.971,4.029,9,9,9s9-4.029,9-9V8H22z" })))),
            createElement("div", null,
                createElement("span", { className: `${cname}__Title` }, data.title),
                data.size ?
                    createElement("span", { className: `${cname}__Size` }, data.size) : ""))));
}

function Heading(props) {
    const blockName = "Heading";
    const data = props.current;
    const content = createElement(Fragment, null,
        createElement(Anchor, { href: data.uri }),
        createElement(SemanticStringArray, { semanticStringArray: data.title }));
    switch (data.depth) {
        case 1: {
            return (createElement(Fragment, null,
                createElement("h1", { id: data.uri, className: `${colorfulBlock(data.color)} \
${blockName} ${blockName}--1` }, content),
                props.children));
        }
        case 2: {
            return (createElement(Fragment, null,
                createElement("h2", { id: data.uri, className: `${colorfulBlock(data.color)} \
${blockName} ${blockName}--2` }, content),
                props.children));
        }
        default: {
            return (createElement(Fragment, null,
                createElement("h3", { id: data.uri, className: `${colorfulBlock(data.color)} \
${blockName} ${blockName}--3` }, content),
                props.children));
        }
    }
}

function Image(props) {
    const blockName = "Image";
    const data = props.current;
    const width = data.fullWidth ? "calc(100vw - 15px)" :
        data.pageWidth ? "100%" : `${data.width}px`;
    const variant = data.fullWidth ? "FullWidth" :
        data.pageWidth ? "PageWidth" : "Normal";
    const height = data.height + "px";
    return (createElement("div", { id: data.uri, className: `${blockName} ${blockName}--${variant}` },
        createElement("figure", null,
            createElement("a", { href: data.source },
                createElement("img", { src: data.source, style: data.fullWidth ? { height } : { width } })),
            data.caption ?
                createElement("figcaption", null,
                    createElement(SemanticStringArray, { semanticStringArray: data.caption })) : "")));
}

function NumberedList(props) {
    return (createElement("li", { key: props.current.uri, id: props.current.uri, className: "NumberedList", value: props.listOrder },
        createElement(SemanticStringArray, { semanticStringArray: props.current.title }),
        props.children));
}
function NumberedListWrapper(props) {
    return (createElement("ol", { key: props.current.uri, className: "NumberedListWrapper" }, props.children));
}

//const iconPageEmpty =
//  <path d="M16,1H4v28h22V11L16,1z M23.172,11H16V3.828L23.172,11z M24,27H6V3h8v10h10V27z" />
const iconPageNonEmpty = createElement("path", { d: "M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z" });
function Page(props) {
    const data = props.current;
    const isRoot = props.current === props.root;
    if (isRoot) {
        const blockName = "PageRoot";
        return (createElement("article", { id: data.uri, className: data.fullWidth ?
                `${blockName} ${blockName}--FullWidth` : `${blockName}` }, props.children));
    }
    else {
        const blockName = "Page";
        return (createElement("a", { id: data.uri, className: blockName, href: data.uri },
            createElement("div", null,
                createElement("div", { className: `${blockName}__Icon` }, data.icon ?
                    createElement(Icon, { src: data.icon, size: "1em" }) :
                    createElement("svg", { viewBox: "0 0 30 30", style: {
                            width: "1.1875em",
                            height: "1.1875em",
                            fill: "inherit",
                            opacity: "0.8"
                        } },
                        createElement("g", null, iconPageNonEmpty))),
                createElement("div", { className: `${blockName}__Title` },
                    createElement(SemanticStringArray, { semanticStringArray: data.title.length ?
                            data.title : [["Untitled"]] })))));
    }
}

function PDF(props) {
    const blockName = "PDF";
    const data = props.current;
    const width = data.fullWidth ? "100%" : data.width;
    const height = data.height;
    return (createElement("div", { id: data.uri, className: blockName },
        createElement("div", { className: `${blockName}__Content` },
            createElement("embed", { width: width, height: height, src: data.source, type: "application/pdf" })),
        data.caption ?
            createElement("p", { className: `${blockName}__Caption` },
                createElement(SemanticStringArray, { semanticStringArray: data.caption })) : ""));
}

function Quote(props) {
    return createElement("blockquote", { ...props });
}
function QuoteDriver(props) {
    const blockName = "Quote";
    const data = props.current;
    // TODO: Use <Text> to wrap data.title
    return (createElement(Quote, { id: data.uri, className: `${colorfulBlock(data.color)} ${blockName}` },
        createElement(SemanticStringArray, { semanticStringArray: data.title }),
        props.children));
}

function TableOfContents(props) {
    const blockName = "TableOfContents";
    const data = props.current;
    const blocks = getBlocksToBePutInTOC(props.root);
    const rendered = [];
    const indentWidth = 24;
    const indentUnit = "px";
    let prevHDepth = 0; // previous heading depth
    let indentNum = 0;
    for (let i = 0; i < blocks.length; i++) {
        const h = blocks[i];
        if (prevHDepth === 0) {
            prevHDepth = h.depth;
        }
        /**
         * Indentation is based on context, e.g. h3 has no indentation when
         * there is no h1 or h2 before it.
         */
        if (h.depth > prevHDepth) {
            /** Increase indentation when smaller heading is encountered. */
            prevHDepth = h.depth;
            indentNum++;
        }
        else if (h.depth < prevHDepth) {
            /**
             * Decrease indentation when bigger heading is encountered,
             * but stop at zero indentation.
             */
            prevHDepth = h.depth;
            if (indentNum > 0)
                indentNum--;
        }
        rendered.push(createElement("li", { key: h.uri, className: `${blockName}__Item` },
            createElement("a", { href: `#${h.uri}` },
                createElement("div", { style: {
                        marginLeft: `${indentNum * indentWidth}${indentUnit}`
                    } },
                    createElement(SemanticStringArray, { semanticStringArray: h.title, noInteractive: true })))));
    }
    return (createElement("ul", { id: data.uri, className: `${colorfulBlock(data.color)} ${blockName}` }, rendered));
}
function getBlocksToBePutInTOC(tree) {
    const blocks = [];
    /** Search for headings in only the top level children blocks. */
    for (let i = 0; i < tree.children.length; i++) {
        const block = tree.children[i];
        switch (block.type) {
            case "heading": {
                blocks.push(block);
                break;
            }
            /** Also headings in column lists. */
            case "column_list": {
                const columnList = block;
                columnList.children.forEach(column => {
                    column.children.forEach(block => {
                        if (block.type === "heading")
                            blocks.push(block);
                    });
                });
                break;
            }
        }
    }
    return blocks;
}

function Text(props) {
    const blockName = "Text";
    const data = props.current;
    /**
     * If I have a color, I use my color.
     * If I don't have a color, I ask my parent for it.
     * If I don't have a parent, then just pretend I have a color.
     */
    const color = data.color ? data.color :
        props.parent ? props.parent.color : data.color;
    return (createElement("div", { id: data.uri, className: `${colorfulBlock(color)} ${blockName}` },
        createElement("p", { className: `${blockName}__Content` },
            createElement(SemanticStringArray, { semanticStringArray: props.current.title })),
        props.children.length ?
            createElement("div", { className: `${blockName}__Children` }, props.children)
            : ""));
}

function ToDo(props) {
    const blockName = "ToDo";
    const data = props.current;
    return (createElement("div", { id: data.uri, className: `${colorfulBlock(data.color)} ${blockName}` },
        createElement("div", { className: `${blockName}__Content` },
            createElement("div", { className: `${blockName}__Icon` }, data.checked ?
                createElement("div", { className: "IconCheckboxChecked" },
                    createElement("svg", { viewBox: "0 0 14 14" },
                        createElement("polygon", { points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039" }))) :
                createElement("div", { className: "IconCheckboxUnchecked" },
                    createElement("svg", { viewBox: "0 0 16 16" },
                        createElement("path", { d: "M1.5,1.5 L1.5,14.5 L14.5,14.5 L14.5,1.5 L1.5,1.5 Z M0,0 L16,0 L16,16 L0,16 L0,0 Z" })))),
            data.checked ?
                createElement("div", { className: `${blockName}__Title ${blockName}__Title--done` },
                    createElement("del", null,
                        createElement(SemanticStringArray, { semanticStringArray: data.title }))) :
                createElement("div", { className: `${blockName}__Title` },
                    createElement(SemanticStringArray, { semanticStringArray: data.title }))),
        props.children.length ?
            createElement("div", { className: `${blockName}__Children` }, props.children) : ""));
}

function Toggle(props) {
    const blockName = "Toggle";
    const data = props.current;
    /**
     * If I have a color, I use my color.
     * If I don't have a color, I ask my parent for it.
     * If I don't have a parent, then just pretend I have a color.
     */
    const color = data.color ? data.color :
        props.parent ? props.parent.color : data.color;
    return (createElement("details", { id: data.uri, className: `${colorfulBlock(color)} ${blockName} ${props.children.length ? `` : `${blockName}--Empty`}` },
        createElement("summary", { className: `${blockName}__Summary` },
            createElement(SemanticStringArray, { semanticStringArray: data.title })),
        createElement("div", { className: `${blockName}__Content` }, props.children)));
}

function Video(props) {
    const blockName = "Video";
    const data = props.current;
    const width = data.fullWidth ? "100%" : data.width;
    return (createElement("div", { id: data.uri, className: blockName },
        createElement("div", { className: `${blockName}__Content` },
            createElement("video", { width: width, controls: true },
                createElement("source", { src: data.source }))),
        data.caption ?
            createElement("p", { className: `${blockName}__Caption` },
                createElement(SemanticStringArray, { semanticStringArray: data.caption })) : ""));
}

const blockRendererRegistry = new Map();
blockRendererRegistry.set("audio", Audio);
blockRendererRegistry.set("bookmark", Bookmark);
blockRendererRegistry.set("bulleted_list", BulletedList);
blockRendererRegistry.set("callout", Callout);
blockRendererRegistry.set("code", Code);
blockRendererRegistry.set("collection_inline", CollectionDriver);
blockRendererRegistry.set("collection_page", CollectionDriver);
blockRendererRegistry.set("column", Column);
blockRendererRegistry.set("column_list", ColumnList);
blockRendererRegistry.set("divider", Divider);
blockRendererRegistry.set("embed", Embed);
blockRendererRegistry.set("equation", EquationDriver);
blockRendererRegistry.set("file", File);
blockRendererRegistry.set("heading", Heading);
blockRendererRegistry.set("image", Image);
blockRendererRegistry.set("numbered_list", NumberedList);
blockRendererRegistry.set("page", Page);
blockRendererRegistry.set("pdf", PDF);
blockRendererRegistry.set("quote", QuoteDriver);
blockRendererRegistry.set("table_of_contents", TableOfContents);
blockRendererRegistry.set("text", Text);
blockRendererRegistry.set("to_do", ToDo);
blockRendererRegistry.set("toggle", Toggle);
blockRendererRegistry.set("video", Video);
const listWrapperRegistry = new Map();
listWrapperRegistry.set("bulleted_list", BulletedListWrapper);
listWrapperRegistry.set("numbered_list", NumberedListWrapper);
function renderBlock(opts) {
    const blockRendererRegistry = opts.blockRendererRegistry;
    const listWrapperRegistry = opts.listWrapperRegistry;
    const childrenData = opts.current.children;
    let childrenRendered = [];
    let listItemQueue = [];
    let listOrder = 1;
    for (let i = 0; i < childrenData.length; i++) {
        const current = childrenData[i];
        const prev = childrenData[i - 1];
        const next = childrenData[i + 1];
        if (prev && prev.type === current.type) {
            listOrder++;
        }
        else {
            listOrder = 1;
        }
        const parent = opts.current;
        const root = opts.root;
        const depth = opts.depth + 1;
        const reactKey = opts.current.uri;
        /**
         * When a block is processed for the first time, it is not rendered
         * but queued in the listItemQueue, and its listLength is set to 0.
         * Once the boundary of the list (a sequence of adjacent blocks of
         * the same type) is found, listLengths of blocks in the listItemQueue
         * are set to the correct value and blocks are rendered.
         *
         * A list boundary is where adjacent blocks are of different types.
         */
        if (listOrder === 1) {
            /** Render the list. */
            const listRendered = renderList(listItemQueue, listWrapperRegistry);
            childrenRendered = childrenRendered.concat(listRendered);
            /** Clear listItemQueue. */
            listItemQueue = [];
        }
        listItemQueue.push({
            current, prev, next, parent, root, depth, listOrder,
            listLength: 0, reactKey, blockRendererRegistry, listWrapperRegistry
        });
    }
    /** Render the last list in children. */
    const listRendered = renderList(listItemQueue, listWrapperRegistry);
    childrenRendered = childrenRendered.concat(listRendered);
    /** Render current block. */
    const Renderer = blockRendererRegistry.get(opts.current.type);
    if (Renderer)
        return (createElement(Renderer, { current: opts.current, prev: opts.prev, next: opts.next, parent: opts.parent, root: opts.root, depth: opts.depth, listOrder: opts.listOrder, listLength: opts.listLength, key: opts.reactKey }, childrenRendered));
    else
        return createElement("div", { key: opts.reactKey }, childrenRendered);
}
/**
 * Render a list of one type, if a ListWrapper of the type is registered,
 * the list will be wrapped by the wrapper.
 * @param listItemQueue
 * @param listWrapperRegistry
 */
function renderList(listItemQueue, listWrapperRegistry) {
    /** Render blocks. */
    const listRendered = [];
    for (let i = 0; i < listItemQueue.length; i++) {
        listItemQueue[i].listLength = listItemQueue.length;
        listRendered.push(renderBlock(listItemQueue[i]));
    }
    /** Render list wrapper. */
    if (listItemQueue.length > 0) {
        const listType = listItemQueue[0].current.type;
        const ListWrapper = listWrapperRegistry.get(listType);
        if (ListWrapper)
            return [createElement(ListWrapper, null, listRendered)];
        else
            return listRendered;
    }
    else {
        return listRendered;
    }
}
/**
 * Render NAST to HTML.
 * @param tree
 */
function renderToHTML(data) {
    return renderToStaticMarkup(renderToJSX(data));
}
/**
 * Render NAST to JSX.Element.
 * @param tree
 */
function renderToJSX(data) {
    if (Array.isArray(data)) {
        return (createElement(SemanticStringArray, { semanticStringArray: data }));
    }
    else {
        return renderBlock({
            current: data,
            root: data,
            depth: 0,
            listOrder: 1,
            listLength: 1,
            reactKey: `d0-c1-${data.type}1`,
            blockRendererRegistry,
            listWrapperRegistry
        });
    }
}

export { renderToHTML, renderToJSX };
